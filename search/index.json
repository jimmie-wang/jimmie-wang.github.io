[{"content":"Java转go 没办法，为了混口饭吃，该转还是得转，人在屋檐下~\n总的来说，go语言在设计和框架上更为简洁轻量。\ngo源码中文网站：https://studygolang.com/pkgdoc\ngo hello world 和java一样，go也有自己的sdk，通过https://go.dev/进行下载安装，会自动配置好环境变量。\nGOROOT是go命令的可执行文件所在目录。GOPATH现在已经作废，最新的官方依赖管理工具是go module，类似Java中的maven和gradle。\n两个命令：\n1 2 go build # 在当前目录下生成与源码文件同名的可执行文件 go install # 在指定目录生成可执行文件，方便与他人共享以及命令方式直接本机运行该go程序，默认安装位置GOPATH/bin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main //程序的包名，当且仅当package是main时可直接运行，且包名和文件夹名可以不一致 /* import \u0026#34;fmt\u0026#34; import \u0026#34;time\u0026#34; */ import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 和javaimport一致，引入依赖 //main函数 func main() { //函数的{ 一定是 和函数名在同一行的，否则编译错误 //golang中的表达式，加\u0026#34;;\u0026#34;, 和不加 都可以，建议是不加 fmt.Println(\u0026#34; hello Go!\u0026#34;) time.Sleep(1 * time.Second) } 变量 go语言变量声明方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package main /* 四种变量的声明方式 */ import ( \u0026#34;fmt\u0026#34; ) // 声明全局变量 方法一、方法二、方法三是可以的 // global variables don\u0026#39;t use := var gA int = 100 var gB = 200 //用方法四来声明全局变量 // := 只能够用在 函数体内来声明 //gC := 200 func main() { //方法一：声明一个变量 默认的值是0 var a int fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Printf(\u0026#34;type of a = %T\\n\u0026#34;, a) //方法二：声明一个变量，初始化一个值 var b int = 100 fmt.Println(\u0026#34;b = \u0026#34;, b) fmt.Printf(\u0026#34;type of b = %T\\n\u0026#34;, b) var bb string = \u0026#34;abcd\u0026#34; fmt.Printf(\u0026#34;bb = %s, type of bb = %T\\n\u0026#34;, bb, bb) //方法三：在初始化的时候，可以省去数据类型，通过值自动匹配当前的变量的数据类型 var c = 100 fmt.Println(\u0026#34;c = \u0026#34;, c) fmt.Printf(\u0026#34;type of c = %T\\n\u0026#34;, c) var cc = \u0026#34;abcd\u0026#34; fmt.Printf(\u0026#34;cc = %s, type of cc = %T\\n\u0026#34;, cc, cc) //方法四：(常用的方法) 省去var关键字，直接自动匹配 e := 100 fmt.Println(\u0026#34;e = \u0026#34;, e) fmt.Printf(\u0026#34;type of e = %T\\n\u0026#34;, e) f := \u0026#34;abcd\u0026#34; fmt.Println(\u0026#34;f = \u0026#34;, f) fmt.Printf(\u0026#34;type of f = %T\\n\u0026#34;, f) g := 3.14 fmt.Println(\u0026#34;g = \u0026#34;, g) fmt.Printf(\u0026#34;type of g = %T\\n\u0026#34;, g) // ===== fmt.Println(\u0026#34;gA = \u0026#34;, gA, \u0026#34;, gB = \u0026#34;, gB) //fmt.Println(\u0026#34;gC = \u0026#34;, gC) // 声明多个变量 var xx, yy int = 100, 200 fmt.Println(\u0026#34;xx = \u0026#34;, xx, \u0026#34;, yy = \u0026#34;, yy) var kk, ll = 100, \u0026#34;Aceld\u0026#34; fmt.Println(\u0026#34;kk = \u0026#34;, kk, \u0026#34;, ll = \u0026#34;, ll) //多行的多变量声明 var ( vv int = 100 jj bool = true ) fmt.Println(\u0026#34;vv = \u0026#34;, vv, \u0026#34;, jj = \u0026#34;, jj) // 更简洁 vvA, jjA := 100, true fmt.Println(\u0026#34;vvA = \u0026#34;, vvA, \u0026#34;, jjA = \u0026#34;, jjA) } 下面是const常量，具备只读属性：\n1 2 3 4 5 6 7 8 //const 来定义枚举类型 const ( //可以在const() 添加一个关键字 iota， 每行的iota都会累加1, 第一行的iota的默认值是0。 // 这东西可读性比较差。。建议看看就行 BEIJING = 10*iota\t//iota = 0 SHANGHAI //iota = 1 SHENZHEN //iota = 2 ) 函数 和java函数不同：\n1.go方法返回值支持多个\n2.在参数和返回值上，都是变量名在前，类型在后\n3.java函数返回值在函数名前，go函数返回值在最后\n常见写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import \u0026#34;fmt\u0026#34; func foo1(a string, b int) int { fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) c := 100 return c } // 返回多个返回值，匿名的 func foo2(a string, b int) (int, int) { fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) return 666, 777 } // 返回多个返回值， 有形参名称的 func foo3(a string, b int) (r1 int, r2 int) { fmt.Println(\u0026#34;---- foo3 ----\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) //r1 r2 属于foo3的形参， 初始化默认的值是0 //r1 r2 作用域空间 是foo3 整个函数体的{}空间 fmt.Println(\u0026#34;r1 = \u0026#34;, r1) fmt.Println(\u0026#34;r2 = \u0026#34;, r2) //给有名称的返回值变量赋值 r1 = 1000 r2 = 2000 return } func foo4(a string, b int) (r1, r2 int) { fmt.Println(\u0026#34;---- foo4 ----\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) return //给有名称的返回值变量赋值 //r1 = 1000 //r2 = 2000 } func main() { c := foo1(\u0026#34;abc\u0026#34;, 555) fmt.Println(\u0026#34;c = \u0026#34;, c) ret1, ret2 := foo2(\u0026#34;haha\u0026#34;, 999) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) ret1, ret2 = foo3(\u0026#34;foo3\u0026#34;, 333) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) ret1, ret2 = foo4(\u0026#34;foo4\u0026#34;, 444) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) } 包管理 包的加载顺序，采取递归形式调用，优先加载常量和变量，再执行每个包的init函数（需要显式定义，否则不执行）\n包中的函数，通过函数名首字母大小写控制包外是否可见\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( _ \u0026#34;GolangStudy/5-init/lib1\u0026#34; // 匿名导入，但不使用，仍然执行init函数 mylib2 \u0026#34;GolangStudy/5-init/lib2\u0026#34; //. \u0026#34;GolangStudy/5-init/lib2\u0026#34; ) func main() { //lib1.lib1Test() //lib2.Lib2Test() mylib2.Lib2Test() //Lib2Test() } 指针 基本类型值传递与指针传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import \u0026#34;fmt\u0026#34; /* func swap(a int ,b int) { var temp int temp = a a = b b = temp } */ func swap(pa *int, pb *int) { var temp int temp = *pa //temp = main::a *pa = *pb // main::a = main::b *pb = temp // main::b = temp } func changePassValue(a int) { // 拷贝一份参数的值给参数变量a a = 10 } func changePassPoint(a *int) { *a = 10 } func main() { a := 1 changePassValue(a) fmt.Println(a) changePassPoint(\u0026amp;a) fmt.Println(a) a = 10 var b int = 20 swap(\u0026amp;a, \u0026amp;b) fmt.Println(\u0026#34;a = \u0026#34;, a, \u0026#34; b = \u0026#34;, b) var p *int p = \u0026amp;a fmt.Println(\u0026amp;a) fmt.Println(p) var pp **int //二级指针，即指针变量的地址，指针的指针 pp = \u0026amp;p fmt.Println(\u0026amp;p) fmt.Println(pp) fmt.Println(**pp) } defer 类似java中的finally，不同的是defer作用于函数，finally一般与try catch搭配使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { testDefer1() testDefer2() } func deferF() { fmt.Println(\u0026#34;deferF\u0026#34;) } func returnF() int { fmt.Println(\u0026#34;returnF\u0026#34;) return 5 } func testDefer1() { //多个defer函数执行顺序 defer fmt.Println(\u0026#34;defer 1\u0026#34;) defer fmt.Println(\u0026#34;defer 2\u0026#34;) defer func() { // defer一个匿名函数 fmt.Println(\u0026#34;defer 3\u0026#34;) }() } func testDefer2() int { defer deferF() // defer函数晚于return执行 return returnF() } Slice 一般开发过程中不用数组\n数组和变长数组Slice，语法是[]int，和java相反\n数组遍历、传参：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func printArray1(myArray [4]int) { //值拷贝！！！！ for index, value := range myArray { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } myArray[0] = 111 } func main() { //固定长度的数组 var myArray1 [10]int myArray2 := [10]int{1, 2, 3, 4, 0} myArray3 := [4]int{11, 22, 33, 44} // 最简单的遍历方式 for i := 0; i \u0026lt; len(myArray1); i++ { fmt.Println(myArray1[i]) } // index-value形式遍历 for index, value := range myArray2 { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } //查看数组的数据类型 fmt.Printf(\u0026#34;myArray1 types = %T\\n\u0026#34;, myArray1) fmt.Printf(\u0026#34;myArray2 types = %T\\n\u0026#34;, myArray2) fmt.Printf(\u0026#34;myArray3 types = %T\\n\u0026#34;, myArray3) printArray1(myArray3) fmt.Println(\u0026#34; ------ \u0026#34;) for index, value := range myArray3 { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } } 切片是引用传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func printArray(myArray []int) { // 切片是引用传递，可修改 // _ 表示匿名的变量，遍历 for _, value := range myArray { fmt.Println(\u0026#34;value = \u0026#34;, value) } myArray[0] = 100 } func main() { myArray := []int{1, 2, 3, 4} // 动态数组，切片 slice fmt.Printf(\u0026#34;myArray type is %T\\n\u0026#34;, myArray) printArray(myArray) fmt.Println(\u0026#34; ==== \u0026#34;) for _, value := range myArray { fmt.Println(\u0026#34;value = \u0026#34;, value) } 切片声明和判空：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { //声明slice1是一个切片，并且初始化，默认值是1，2，3。 长度len是3 slice1 := []int{1, 2, 3} //声明slice1是一个切片，但是并没有给slice分配空间 //var slice1 []int slice1 = make([]int, 3) //开辟3个空间 ，默认值是0 //声明slice1是一个切片，同时给slice分配空间，3个空间，初始化值是0 //var slice1 []int = make([]int, 3) //声明slice1是一个切片，同时给slice分配空间，3个空间，初始化值是0, 通过:=推导出slice是一个切片 //slice1 := make([]int, 3) fmt.Printf(\u0026#34;len = %d, slice = %v\\n\u0026#34;, len(slice1), slice1) //判断一个silce容量是否为0。是否为nil，统一的 // 不像java存在list为null和list长度为0但不为null两种情况 if slice1 == nil { fmt.Println(\u0026#34;slice1 是一个空切片\u0026#34;) } else { fmt.Println(\u0026#34;slice1 是有空间的\u0026#34;) } } 切片追加操作，len为当前长度，capacity为最大容量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; func main() { var numbers = make([]int, 3, 5) myArray2 := [10]int{1, 2, 3, 4, 0} fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(myArray2), cap(myArray2), myArray2) //向numbers切片追加一个元素1, numbers len = 4， [0,0,0,1], cap = 5 numbers = append(numbers, 1) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) //向numbers切片追加一个元素2, numbers len = 5， [0,0,0,1,2], cap = 5 numbers = append(numbers, 2) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) //向一个容量cap已经满的slice 追加元素，自动扩容长度为原来的2倍 numbers = append(numbers, 3) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) fmt.Println(\u0026#34;-=-------\u0026#34;) var numbers2 = make([]int, 3) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers2), cap(numbers2), numbers2) numbers2 = append(numbers2, 1) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers2), cap(numbers2), numbers2) } 切片截取操作：普通截取为指针赋值，不涉及元素深拷贝。若要将底层数组也拷贝到新切片，则需要copy：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { s := []int{1, 2, 3} //len = 3, cap = 3, [1,2,3] //[0, 2) s1 := s[0:2] // [1, 2] fmt.Println(s1) s1[0] = 100 // 浅拷贝，s1还是指向s的内存空间，修改值时s也跟着变 fmt.Println(s) fmt.Println(s1) //copy 可以将底层数组的slice一起进行拷贝 s2 := make([]int, 3) //s2 = [0,0,0] //将s中的值 依次拷贝到s2中 copy(s2, s) fmt.Println(s2) } map map判空和slice同理，声明方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import \u0026#34;fmt\u0026#34; func main() { //===\u0026gt; 第一种声明方式 //声明myMap1是一种map类型 key是string， value是string var myMap1 map[string]string if myMap1 == nil { fmt.Println(\u0026#34;myMap1 是一个空map\u0026#34;) } //在使用map前， 先用make给map分配数据空间 myMap1 = make(map[string]string, 10) myMap1[\u0026#34;one\u0026#34;] = \u0026#34;java\u0026#34; myMap1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; myMap1[\u0026#34;three\u0026#34;] = \u0026#34;python\u0026#34; fmt.Println(myMap1) //===\u0026gt; 第二种声明方式 myMap2 := make(map[int]string) myMap2[1] = \u0026#34;java\u0026#34; myMap2[2] = \u0026#34;c++\u0026#34; myMap2[3] = \u0026#34;python\u0026#34; fmt.Println(myMap2) //===\u0026gt; 第三种声明方式 myMap3 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;c++\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;python\u0026#34;, } fmt.Println(myMap3) } map的各种操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func printMap(cityMap map[string]string) { // cityMap 是一个引用传递 // 遍历和slice类似，这里是key value for key, value := range cityMap { fmt.Println(\u0026#34;key = \u0026#34;, key) fmt.Println(\u0026#34;value = \u0026#34;, value) } } func ChangeValue(cityMap map[string]string) { cityMap[\u0026#34;England\u0026#34;] = \u0026#34;London\u0026#34; } func main() { cityMap := make(map[string]string) //添加 cityMap[\u0026#34;China\u0026#34;] = \u0026#34;Beijing\u0026#34; cityMap[\u0026#34;Japan\u0026#34;] = \u0026#34;Tokyo\u0026#34; cityMap[\u0026#34;USA\u0026#34;] = \u0026#34;NewYork\u0026#34; //遍历 printMap(cityMap) //删除 delete(cityMap, \u0026#34;China\u0026#34;) //修改 cityMap[\u0026#34;USA\u0026#34;] = \u0026#34;DC\u0026#34; ChangeValue(cityMap) fmt.Println(\u0026#34;-------\u0026#34;) //遍历 printMap(cityMap) } 面向对象 type关键字：声明一种类型\n结构体 对标java的类，通过结构体声明变量名首字母控制可见性（封装）\n结构体声明和传参操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package main import \u0026#34;fmt\u0026#34; // Hero 如果类名首字母大写，表示其他包也能够访问 type Hero struct { //如果说类的属性首字母大写, 表示该属性是对外能够访问的，否则的话只能够类的内部访问 Name string Ad int level int // 外部没法直接访问，只能get方法 } /* func (this Hero) Show() { fmt.Println(\u0026#34;Name = \u0026#34;, this.Name) fmt.Println(\u0026#34;Ad = \u0026#34;, this.Ad) fmt.Println(\u0026#34;Level = \u0026#34;, this.Level) } func (this Hero) GetName() string { return this.Name } func (this Hero) SetName(newName string) { //this 是调用该方法的对象的一个副本（拷贝），所以不能这么写 this.Name = newName } */ // Show this 是调用该方法的对象的一个副本（拷贝）， func (hero *Hero) Show() { fmt.Println(\u0026#34;Name = \u0026#34;, hero.Name) fmt.Println(\u0026#34;Ad = \u0026#34;, hero.Ad) fmt.Println(\u0026#34;Level = \u0026#34;, hero.level) } func (hero *Hero) GetName() string { return hero.Name } func (hero *Hero) SetName(newName string) { hero.Name = newName } func main() { //创建一个对象 hero := Hero{Name: \u0026#34;zhang3\u0026#34;, Ad: 100} hero.Show() hero.SetName(\u0026#34;li4\u0026#34;) hero.Show() } 继承 语法比较清奇，只需要写一个结构体名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import \u0026#34;fmt\u0026#34; type Human struct { name string sex string } type SHuman struct { Human sname string ssex string } func (this *Human) Eat() { fmt.Println(\u0026#34;Human.Eat()...\u0026#34;) } func (this *Human) Walk() { fmt.Println(\u0026#34;Human.Walk()...\u0026#34;) } // //func (this *SHuman) Walk() { //\tfmt.Println(\u0026#34;SHuman.Walk()...\u0026#34;) //} //================= type SuperMan struct { //Human //SuperMan类继承了Human类的方法 SHuman level int } // 重定义父类的方法Eat() func (this *SuperMan) Eat() { fmt.Println(\u0026#34;SuperMan.Eat()...\u0026#34;) } // 子类的新方法 func (this *SuperMan) Fly() { fmt.Println(\u0026#34;SuperMan.Fly()...\u0026#34;) } func (this *SuperMan) Print() { fmt.Println(\u0026#34;name = \u0026#34;, this.name) fmt.Println(\u0026#34;sex = \u0026#34;, this.sex) fmt.Println(\u0026#34;level = \u0026#34;, this.level) } func main() { //h := Human{\u0026#34;zhang3\u0026#34;, \u0026#34;female\u0026#34;} //h.Eat() //h.Walk() //定义一个子类对象 //s := SuperMan{Human{\u0026#34;li4\u0026#34;, \u0026#34;female\u0026#34;}, 88} var s SuperMan s.name = \u0026#34;li4\u0026#34; s.sex = \u0026#34;male\u0026#34; s.level = 88 s.Walk() //父类的方法 s.Eat() //子类的方法 s.Fly() //子类的方法 s.Print() } 多态 interface实现，需要实现结构体绑定全部接口方法，才算实现该接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package main import \u0026#34;fmt\u0026#34; // 本质是一个指针 type AnimalIF interface { Sleep() GetColor() string //获取动物的颜色 GetType() string //获取动物的种类 } // 具体的类 type Cat struct { color string //猫的颜色 } func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat is Sleep\u0026#34;) } func (this *Cat) GetColor() string { return this.color } func (this *Cat) GetType() string { return \u0026#34;Cat\u0026#34; } // 具体的类 type Dog struct { color string } func (this *Dog) Sleep() { fmt.Println(\u0026#34;Dog is Sleep\u0026#34;) } func (this *Dog) GetColor() string { return this.color } func (this *Dog) GetType() string { return \u0026#34;Dog\u0026#34; } func showAnimal(animal AnimalIF) { animal.Sleep() //多态 fmt.Println(\u0026#34;color = \u0026#34;, animal.GetColor()) fmt.Println(\u0026#34;kind = \u0026#34;, animal.GetType()) } func main() { var animal AnimalIF //接口的数据类型， 父类指针，所以下面要用\u0026amp;符号 animal = \u0026amp;Cat{\u0026#34;Green\u0026#34;} animal.Sleep() //调用的就是Cat的Sleep()方法 , 多态的现象 animal = \u0026amp;Dog{\u0026#34;Yellow\u0026#34;} animal.Sleep() // 调用Dog的Sleep方法，多态的现象 cat := Cat{\u0026#34;Green\u0026#34;} dog := Dog{\u0026#34;Yellow\u0026#34;} showAnimal(\u0026amp;cat) showAnimal(\u0026amp;dog) } interface interface分为iface和eface，在sdk的runtime包中。\neface是空接口，即代码中的interface{}，包含类型和实例数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { var a string //pair\u0026lt;statictype:string, value:\u0026#34;aceld\u0026#34;\u0026gt; a = \u0026#34;aceld\u0026#34; //pair\u0026lt;type:string, value:\u0026#34;aceld\u0026#34;\u0026gt; var allType interface{} allType = a str, _ := allType.(string) fmt.Println(str) } 任何类型都可以赋值给interface{}空接口，此时要注意其类型为：\n这个类型还是interface{}，而不是string，如果要使用string值，可以进行断言。\n反射 在计算机学中，反射是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够 “观察” 并且修改自己的行为（来自维基百科）。\n反射能够带来的能力有：\n1.一套代码能够操作任意类型的对象\n反射具体代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Println(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) //获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) //通过type 获取里面的字段 //1. 获取interface的reflect.Type，通过Type得到NumField ,进行遍历 //2. 得到每个field，数据类型 //3. 通过filed有一个Interface()方法等到 对应的value for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 结构体标签 给结构体变量绑定多个标签，目前见过的例子有json的序列化字段名\n通过反射获取结构体标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type resume struct { Name string `info:\u0026#34;name\u0026#34; doc:\u0026#34;我的名字\u0026#34;` Sex string `info:\u0026#34;sex\u0026#34;` } func findTag(str interface{}) { t := reflect.TypeOf(str).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { taginfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagdoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info: \u0026#34;, taginfo, \u0026#34; doc: \u0026#34;, tagdoc) } } func main() { var re resume findTag(\u0026amp;re) } json中的结构体标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Movie struct { Title string `json:\u0026#34;title\u0026#34;` Year int `json:\u0026#34;year\u0026#34;` Price int `json:\u0026#34;rmb\u0026#34;` Actors []string `json:\u0026#34;actors\u0026#34;` } func main() { movie := Movie{\u0026#34;喜剧之王\u0026#34;, 2000, 10, []string{\u0026#34;xingye\u0026#34;, \u0026#34;zhangbozhi\u0026#34;}} //编码的过程 结构体---\u0026gt; json jsonStr, err := json.Marshal(movie) if err != nil { fmt.Println(\u0026#34;json marshal error\u0026#34;, err) return } fmt.Printf(\u0026#34;jsonStr = %s\\n\u0026#34;, jsonStr) //解码的过程 jsonstr ---\u0026gt; 结构体 //jsonStr = {\u0026#34;title\u0026#34;:\u0026#34;喜剧之王\u0026#34;,\u0026#34;year\u0026#34;:2000,\u0026#34;rmb\u0026#34;:10,\u0026#34;actors\u0026#34;:[\u0026#34;xingye\u0026#34;,\u0026#34;zhangbozhi\u0026#34;]} myMovie := Movie{} err = json.Unmarshal(jsonStr, \u0026amp;myMovie) // 结构体传参是值传递，因此需要传指针 if err != nil { fmt.Println(\u0026#34;json unmarshal error \u0026#34;, err) return } fmt.Printf(\u0026#34;%v\\n\u0026#34;, myMovie) } goroutine 协程是比线程更轻量级的运行单元\n","date":"2025-07-19T18:12:46+08:00","permalink":"https://jimmie-wang.github.io/p/java2goland/","title":"Java2goland"},{"content":"","date":"2025-07-17T17:44:24+08:00","permalink":"https://jimmie-wang.github.io/p/newnewnew/","title":"Newnewnew"},{"content":"hello world ","date":"2025-07-17T11:24:00+08:00","permalink":"https://jimmie-wang.github.io/p/myfirstblog/","title":"MyFirstBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://jimmie-wang.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://jimmie-wang.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://jimmie-wang.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://jimmie-wang.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://jimmie-wang.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://jimmie-wang.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://jimmie-wang.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://jimmie-wang.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://jimmie-wang.github.io/p/emoji-support/","title":"Emoji Support"}]