[{"content":"Java转go 没办法，为了混口饭吃，该转还是得转，人在屋檐下~\n总的来说，go语言在设计和框架上更为简洁轻量。\ngo源码中文网站：https://studygolang.com/pkgdoc\ngo hello world 和java一样，go也有自己的sdk，通过https://go.dev/进行下载安装，会自动配置好环境变量。\nGOROOT是go命令的可执行文件所在目录。GOPATH现在已经作废，最新的官方依赖管理工具是go module，类似Java中的maven和gradle。\n两个命令：\n1 2 go build # 在当前目录下生成与源码文件同名的可执行文件 go install # 在指定目录生成可执行文件，方便与他人共享以及命令方式直接本机运行该go程序，默认安装位置GOPATH/bin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 package main //程序的包名，当且仅当package是main时可直接运行，且包名和文件夹名可以不一致 /* import \u0026#34;fmt\u0026#34; import \u0026#34;time\u0026#34; */ import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 和javaimport一致，引入依赖 //main函数 func main() { //函数的{ 一定是 和函数名在同一行的，否则编译错误 //golang中的表达式，加\u0026#34;;\u0026#34;, 和不加 都可以，建议是不加 fmt.Println(\u0026#34; hello Go!\u0026#34;) time.Sleep(1 * time.Second) } 变量 go语言变量声明方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 package main /* 四种变量的声明方式 */ import ( \u0026#34;fmt\u0026#34; ) // 声明全局变量 方法一、方法二、方法三是可以的 // global variables don\u0026#39;t use := var gA int = 100 var gB = 200 //用方法四来声明全局变量 // := 只能够用在 函数体内来声明 //gC := 200 func main() { //方法一：声明一个变量 默认的值是0 var a int fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Printf(\u0026#34;type of a = %T\\n\u0026#34;, a) //方法二：声明一个变量，初始化一个值 var b int = 100 fmt.Println(\u0026#34;b = \u0026#34;, b) fmt.Printf(\u0026#34;type of b = %T\\n\u0026#34;, b) var bb string = \u0026#34;abcd\u0026#34; fmt.Printf(\u0026#34;bb = %s, type of bb = %T\\n\u0026#34;, bb, bb) //方法三：在初始化的时候，可以省去数据类型，通过值自动匹配当前的变量的数据类型 var c = 100 fmt.Println(\u0026#34;c = \u0026#34;, c) fmt.Printf(\u0026#34;type of c = %T\\n\u0026#34;, c) var cc = \u0026#34;abcd\u0026#34; fmt.Printf(\u0026#34;cc = %s, type of cc = %T\\n\u0026#34;, cc, cc) //方法四：(常用的方法) 省去var关键字，直接自动匹配 e := 100 fmt.Println(\u0026#34;e = \u0026#34;, e) fmt.Printf(\u0026#34;type of e = %T\\n\u0026#34;, e) f := \u0026#34;abcd\u0026#34; fmt.Println(\u0026#34;f = \u0026#34;, f) fmt.Printf(\u0026#34;type of f = %T\\n\u0026#34;, f) g := 3.14 fmt.Println(\u0026#34;g = \u0026#34;, g) fmt.Printf(\u0026#34;type of g = %T\\n\u0026#34;, g) // ===== fmt.Println(\u0026#34;gA = \u0026#34;, gA, \u0026#34;, gB = \u0026#34;, gB) //fmt.Println(\u0026#34;gC = \u0026#34;, gC) // 声明多个变量 var xx, yy int = 100, 200 fmt.Println(\u0026#34;xx = \u0026#34;, xx, \u0026#34;, yy = \u0026#34;, yy) var kk, ll = 100, \u0026#34;Aceld\u0026#34; fmt.Println(\u0026#34;kk = \u0026#34;, kk, \u0026#34;, ll = \u0026#34;, ll) //多行的多变量声明 var ( vv int = 100 jj bool = true ) fmt.Println(\u0026#34;vv = \u0026#34;, vv, \u0026#34;, jj = \u0026#34;, jj) // 更简洁 vvA, jjA := 100, true fmt.Println(\u0026#34;vvA = \u0026#34;, vvA, \u0026#34;, jjA = \u0026#34;, jjA) } 下面是const常量，具备只读属性：\n1 2 3 4 5 6 7 8 //const 来定义枚举类型 const ( //可以在const() 添加一个关键字 iota， 每行的iota都会累加1, 第一行的iota的默认值是0。 // 这东西可读性比较差。。建议看看就行 BEIJING = 10*iota\t//iota = 0 SHANGHAI //iota = 1 SHENZHEN //iota = 2 ) 函数 和java函数不同：\n1.go方法返回值支持多个\n2.在参数和返回值上，都是变量名在前，类型在后\n3.java函数返回值在函数名前，go函数返回值在最后\n常见写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 package main import \u0026#34;fmt\u0026#34; func foo1(a string, b int) int { fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) c := 100 return c } // 返回多个返回值，匿名的 func foo2(a string, b int) (int, int) { fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) return 666, 777 } // 返回多个返回值， 有形参名称的 func foo3(a string, b int) (r1 int, r2 int) { fmt.Println(\u0026#34;---- foo3 ----\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) //r1 r2 属于foo3的形参， 初始化默认的值是0 //r1 r2 作用域空间 是foo3 整个函数体的{}空间 fmt.Println(\u0026#34;r1 = \u0026#34;, r1) fmt.Println(\u0026#34;r2 = \u0026#34;, r2) //给有名称的返回值变量赋值 r1 = 1000 r2 = 2000 return } func foo4(a string, b int) (r1, r2 int) { fmt.Println(\u0026#34;---- foo4 ----\u0026#34;) fmt.Println(\u0026#34;a = \u0026#34;, a) fmt.Println(\u0026#34;b = \u0026#34;, b) return //给有名称的返回值变量赋值 //r1 = 1000 //r2 = 2000 } func main() { c := foo1(\u0026#34;abc\u0026#34;, 555) fmt.Println(\u0026#34;c = \u0026#34;, c) ret1, ret2 := foo2(\u0026#34;haha\u0026#34;, 999) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) ret1, ret2 = foo3(\u0026#34;foo3\u0026#34;, 333) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) ret1, ret2 = foo4(\u0026#34;foo4\u0026#34;, 444) fmt.Println(\u0026#34;ret1 = \u0026#34;, ret1, \u0026#34; ret2 = \u0026#34;, ret2) } 包管理 go之前使用GOPATH，强制项目源代码放在GOPATH下\u0026hellip;且没有依赖版本控制概念，无法指定版本号维护依赖\u0026hellip;\n现行的依赖管理模式是go module\n包的加载顺序，采取递归形式调用，优先加载常量和变量，再执行每个包的init函数（需要显式定义，否则不执行）\n包中的函数，通过函数名首字母大小写控制包外是否可见\n例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 package main import ( _ \u0026#34;GolangStudy/5-init/lib1\u0026#34; // 匿名导入，但不使用，仍然执行init函数 mylib2 \u0026#34;GolangStudy/5-init/lib2\u0026#34; //. \u0026#34;GolangStudy/5-init/lib2\u0026#34; ) func main() { //lib1.lib1Test() //lib2.Lib2Test() mylib2.Lib2Test() //Lib2Test() } 指针 基本类型值传递与指针传递：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 package main import \u0026#34;fmt\u0026#34; /* func swap(a int ,b int) { var temp int temp = a a = b b = temp } */ func swap(pa *int, pb *int) { var temp int temp = *pa //temp = main::a *pa = *pb // main::a = main::b *pb = temp // main::b = temp } func changePassValue(a int) { // 拷贝一份参数的值给参数变量a a = 10 } func changePassPoint(a *int) { *a = 10 } func main() { a := 1 changePassValue(a) fmt.Println(a) changePassPoint(\u0026amp;a) fmt.Println(a) a = 10 var b int = 20 swap(\u0026amp;a, \u0026amp;b) fmt.Println(\u0026#34;a = \u0026#34;, a, \u0026#34; b = \u0026#34;, b) var p *int p = \u0026amp;a fmt.Println(\u0026amp;a) fmt.Println(p) var pp **int //二级指针，即指针变量的地址，指针的指针 pp = \u0026amp;p fmt.Println(\u0026amp;p) fmt.Println(pp) fmt.Println(**pp) } defer 类似java中的finally，不同的是defer作用于函数，finally一般与try catch搭配使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 package main import \u0026#34;fmt\u0026#34; func main() { testDefer1() testDefer2() } func deferF() { fmt.Println(\u0026#34;deferF\u0026#34;) } func returnF() int { fmt.Println(\u0026#34;returnF\u0026#34;) return 5 } func testDefer1() { //多个defer函数执行顺序 defer fmt.Println(\u0026#34;defer 1\u0026#34;) defer fmt.Println(\u0026#34;defer 2\u0026#34;) defer func() { // defer一个匿名函数 fmt.Println(\u0026#34;defer 3\u0026#34;) }() } func testDefer2() int { defer deferF() // defer函数晚于return执行 return returnF() } Slice 一般开发过程中不用数组\n数组和变长数组Slice，语法是[]int，和java相反\n数组遍历、传参：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func printArray1(myArray [4]int) { //值拷贝！！！！ for index, value := range myArray { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } myArray[0] = 111 } func main() { //固定长度的数组 var myArray1 [10]int myArray2 := [10]int{1, 2, 3, 4, 0} myArray3 := [4]int{11, 22, 33, 44} // 最简单的遍历方式 for i := 0; i \u0026lt; len(myArray1); i++ { fmt.Println(myArray1[i]) } // index-value形式遍历 for index, value := range myArray2 { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } //查看数组的数据类型 fmt.Printf(\u0026#34;myArray1 types = %T\\n\u0026#34;, myArray1) fmt.Printf(\u0026#34;myArray2 types = %T\\n\u0026#34;, myArray2) fmt.Printf(\u0026#34;myArray3 types = %T\\n\u0026#34;, myArray3) printArray1(myArray3) fmt.Println(\u0026#34; ------ \u0026#34;) for index, value := range myArray3 { fmt.Println(\u0026#34;index = \u0026#34;, index, \u0026#34;, value = \u0026#34;, value) } } 切片是引用传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 func printArray(myArray []int) { // 切片是引用传递，可修改 // _ 表示匿名的变量，遍历 for _, value := range myArray { fmt.Println(\u0026#34;value = \u0026#34;, value) } myArray[0] = 100 } func main() { myArray := []int{1, 2, 3, 4} // 动态数组，切片 slice fmt.Printf(\u0026#34;myArray type is %T\\n\u0026#34;, myArray) printArray(myArray) fmt.Println(\u0026#34; ==== \u0026#34;) for _, value := range myArray { fmt.Println(\u0026#34;value = \u0026#34;, value) } 切片声明和判空：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import \u0026#34;fmt\u0026#34; func main() { //声明slice1是一个切片，并且初始化，默认值是1，2，3。 长度len是3 slice1 := []int{1, 2, 3} //声明slice1是一个切片，但是并没有给slice分配空间 //var slice1 []int slice1 = make([]int, 3) //开辟3个空间 ，默认值是0 //声明slice1是一个切片，同时给slice分配空间，3个空间，初始化值是0 //var slice1 []int = make([]int, 3) //声明slice1是一个切片，同时给slice分配空间，3个空间，初始化值是0, 通过:=推导出slice是一个切片 //slice1 := make([]int, 3) fmt.Printf(\u0026#34;len = %d, slice = %v\\n\u0026#34;, len(slice1), slice1) //判断一个silce容量是否为0。是否为nil，统一的 // 不像java存在list为null和list长度为0但不为null两种情况 if slice1 == nil { fmt.Println(\u0026#34;slice1 是一个空切片\u0026#34;) } else { fmt.Println(\u0026#34;slice1 是有空间的\u0026#34;) } } 切片追加操作，len为当前长度，capacity为最大容量\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 package main import \u0026#34;fmt\u0026#34; func main() { var numbers = make([]int, 3, 5) myArray2 := [10]int{1, 2, 3, 4, 0} fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(myArray2), cap(myArray2), myArray2) //向numbers切片追加一个元素1, numbers len = 4， [0,0,0,1], cap = 5 numbers = append(numbers, 1) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) //向numbers切片追加一个元素2, numbers len = 5， [0,0,0,1,2], cap = 5 numbers = append(numbers, 2) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) //向一个容量cap已经满的slice 追加元素，自动扩容长度为原来的2倍 numbers = append(numbers, 3) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers), cap(numbers), numbers) fmt.Println(\u0026#34;-=-------\u0026#34;) var numbers2 = make([]int, 3) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers2), cap(numbers2), numbers2) numbers2 = append(numbers2, 1) fmt.Printf(\u0026#34;len = %d, cap = %d, slice = %v\\n\u0026#34;, len(numbers2), cap(numbers2), numbers2) } 切片截取操作：普通截取为指针赋值，不涉及元素深拷贝。若要将底层数组也拷贝到新切片，则需要copy：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { s := []int{1, 2, 3} //len = 3, cap = 3, [1,2,3] //[0, 2) s1 := s[0:2] // [1, 2] fmt.Println(s1) s1[0] = 100 // 浅拷贝，s1还是指向s的内存空间，修改值时s也跟着变 fmt.Println(s) fmt.Println(s1) //copy 可以将底层数组的slice一起进行拷贝 s2 := make([]int, 3) //s2 = [0,0,0] //将s中的值 依次拷贝到s2中 copy(s2, s) fmt.Println(s2) } map map判空和slice同理，声明方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import \u0026#34;fmt\u0026#34; func main() { //===\u0026gt; 第一种声明方式 //声明myMap1是一种map类型 key是string， value是string var myMap1 map[string]string if myMap1 == nil { fmt.Println(\u0026#34;myMap1 是一个空map\u0026#34;) } //在使用map前， 先用make给map分配数据空间 myMap1 = make(map[string]string, 10) myMap1[\u0026#34;one\u0026#34;] = \u0026#34;java\u0026#34; myMap1[\u0026#34;two\u0026#34;] = \u0026#34;c++\u0026#34; myMap1[\u0026#34;three\u0026#34;] = \u0026#34;python\u0026#34; fmt.Println(myMap1) //===\u0026gt; 第二种声明方式 myMap2 := make(map[int]string) myMap2[1] = \u0026#34;java\u0026#34; myMap2[2] = \u0026#34;c++\u0026#34; myMap2[3] = \u0026#34;python\u0026#34; fmt.Println(myMap2) //===\u0026gt; 第三种声明方式 myMap3 := map[string]string{ \u0026#34;one\u0026#34;: \u0026#34;php\u0026#34;, \u0026#34;two\u0026#34;: \u0026#34;c++\u0026#34;, \u0026#34;three\u0026#34;: \u0026#34;python\u0026#34;, } fmt.Println(myMap3) } map的各种操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func printMap(cityMap map[string]string) { // cityMap 是一个引用传递 // 遍历和slice类似，这里是key value for key, value := range cityMap { fmt.Println(\u0026#34;key = \u0026#34;, key) fmt.Println(\u0026#34;value = \u0026#34;, value) } } func ChangeValue(cityMap map[string]string) { cityMap[\u0026#34;England\u0026#34;] = \u0026#34;London\u0026#34; } func main() { cityMap := make(map[string]string) //添加 cityMap[\u0026#34;China\u0026#34;] = \u0026#34;Beijing\u0026#34; cityMap[\u0026#34;Japan\u0026#34;] = \u0026#34;Tokyo\u0026#34; cityMap[\u0026#34;USA\u0026#34;] = \u0026#34;NewYork\u0026#34; //遍历 printMap(cityMap) //删除 delete(cityMap, \u0026#34;China\u0026#34;) //修改 cityMap[\u0026#34;USA\u0026#34;] = \u0026#34;DC\u0026#34; ChangeValue(cityMap) fmt.Println(\u0026#34;-------\u0026#34;) //遍历 printMap(cityMap) } 面向对象 type关键字：声明一种类型\n结构体 对标java的类，通过结构体声明变量名首字母控制可见性（封装）\n结构体声明和传参操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 package main import \u0026#34;fmt\u0026#34; // Hero 如果类名首字母大写，表示其他包也能够访问 type Hero struct { //如果说类的属性首字母大写, 表示该属性是对外能够访问的，否则的话只能够类的内部访问 Name string Ad int level int // 外部没法直接访问，只能get方法 } /* func (this Hero) Show() { fmt.Println(\u0026#34;Name = \u0026#34;, this.Name) fmt.Println(\u0026#34;Ad = \u0026#34;, this.Ad) fmt.Println(\u0026#34;Level = \u0026#34;, this.Level) } func (this Hero) GetName() string { return this.Name } func (this Hero) SetName(newName string) { //this 是调用该方法的对象的一个副本（拷贝），所以不能这么写 this.Name = newName } */ // Show this 是调用该方法的对象的一个副本（拷贝）， func (hero *Hero) Show() { fmt.Println(\u0026#34;Name = \u0026#34;, hero.Name) fmt.Println(\u0026#34;Ad = \u0026#34;, hero.Ad) fmt.Println(\u0026#34;Level = \u0026#34;, hero.level) } func (hero *Hero) GetName() string { return hero.Name } func (hero *Hero) SetName(newName string) { hero.Name = newName } func main() { //创建一个对象 hero := Hero{Name: \u0026#34;zhang3\u0026#34;, Ad: 100} hero.Show() hero.SetName(\u0026#34;li4\u0026#34;) hero.Show() } 继承 语法比较清奇，只需要写一个结构体名：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 package main import \u0026#34;fmt\u0026#34; type Human struct { name string sex string } type SHuman struct { Human sname string ssex string } func (this *Human) Eat() { fmt.Println(\u0026#34;Human.Eat()...\u0026#34;) } func (this *Human) Walk() { fmt.Println(\u0026#34;Human.Walk()...\u0026#34;) } // //func (this *SHuman) Walk() { //\tfmt.Println(\u0026#34;SHuman.Walk()...\u0026#34;) //} //================= type SuperMan struct { //Human //SuperMan类继承了Human类的方法 SHuman level int } // 重定义父类的方法Eat() func (this *SuperMan) Eat() { fmt.Println(\u0026#34;SuperMan.Eat()...\u0026#34;) } // 子类的新方法 func (this *SuperMan) Fly() { fmt.Println(\u0026#34;SuperMan.Fly()...\u0026#34;) } func (this *SuperMan) Print() { fmt.Println(\u0026#34;name = \u0026#34;, this.name) fmt.Println(\u0026#34;sex = \u0026#34;, this.sex) fmt.Println(\u0026#34;level = \u0026#34;, this.level) } func main() { //h := Human{\u0026#34;zhang3\u0026#34;, \u0026#34;female\u0026#34;} //h.Eat() //h.Walk() //定义一个子类对象 //s := SuperMan{Human{\u0026#34;li4\u0026#34;, \u0026#34;female\u0026#34;}, 88} var s SuperMan s.name = \u0026#34;li4\u0026#34; s.sex = \u0026#34;male\u0026#34; s.level = 88 s.Walk() //父类的方法 s.Eat() //子类的方法 s.Fly() //子类的方法 s.Print() } 多态 interface实现，需要实现结构体绑定全部接口方法，才算实现该接口\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 package main import \u0026#34;fmt\u0026#34; // 本质是一个指针 type AnimalIF interface { Sleep() GetColor() string //获取动物的颜色 GetType() string //获取动物的种类 } // 具体的类 type Cat struct { color string //猫的颜色 } func (this *Cat) Sleep() { fmt.Println(\u0026#34;Cat is Sleep\u0026#34;) } func (this *Cat) GetColor() string { return this.color } func (this *Cat) GetType() string { return \u0026#34;Cat\u0026#34; } // 具体的类 type Dog struct { color string } func (this *Dog) Sleep() { fmt.Println(\u0026#34;Dog is Sleep\u0026#34;) } func (this *Dog) GetColor() string { return this.color } func (this *Dog) GetType() string { return \u0026#34;Dog\u0026#34; } func showAnimal(animal AnimalIF) { animal.Sleep() //多态 fmt.Println(\u0026#34;color = \u0026#34;, animal.GetColor()) fmt.Println(\u0026#34;kind = \u0026#34;, animal.GetType()) } func main() { var animal AnimalIF //接口的数据类型， 父类指针，所以下面要用\u0026amp;符号 animal = \u0026amp;Cat{\u0026#34;Green\u0026#34;} animal.Sleep() //调用的就是Cat的Sleep()方法 , 多态的现象 animal = \u0026amp;Dog{\u0026#34;Yellow\u0026#34;} animal.Sleep() // 调用Dog的Sleep方法，多态的现象 cat := Cat{\u0026#34;Green\u0026#34;} dog := Dog{\u0026#34;Yellow\u0026#34;} showAnimal(\u0026amp;cat) showAnimal(\u0026amp;dog) } interface interface分为iface和eface，在sdk的runtime包中。\neface是空接口，即代码中的interface{}，包含类型和实例数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 package main import \u0026#34;fmt\u0026#34; func main() { var a string //pair\u0026lt;statictype:string, value:\u0026#34;aceld\u0026#34;\u0026gt; a = \u0026#34;aceld\u0026#34; //pair\u0026lt;type:string, value:\u0026#34;aceld\u0026#34;\u0026gt; var allType interface{} allType = a str, _ := allType.(string) fmt.Println(str) } 任何类型都可以赋值给interface{}空接口，此时要注意其类型为：\n这个类型还是interface{}，而不是string，如果要使用string值，可以进行断言。\n反射 在计算机学中，反射是指计算机程序在运行时（runtime）可以访问、检测和修改它本身状态或行为的一种能力。用比喻来说，反射就是程序在运行的时候能够 “观察” 并且修改自己的行为（来自维基百科）。\n反射能够带来的能力有：\n1.一套代码能够操作任意类型的对象\n反射具体代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type User struct { Id int Name string Age int } func (this User) Call() { fmt.Println(\u0026#34;user is called ..\u0026#34;) fmt.Printf(\u0026#34;%v\\n\u0026#34;, this) } func main() { user := User{1, \u0026#34;Aceld\u0026#34;, 18} DoFiledAndMethod(user) } func DoFiledAndMethod(input interface{}) { //获取input的type inputType := reflect.TypeOf(input) fmt.Println(\u0026#34;inputType is :\u0026#34;, inputType.Name()) //获取input的value inputValue := reflect.ValueOf(input) fmt.Println(\u0026#34;inputValue is:\u0026#34;, inputValue) //通过type 获取里面的字段 //1. 获取interface的reflect.Type，通过Type得到NumField ,进行遍历 //2. 得到每个field，数据类型 //3. 通过filed有一个Interface()方法等到 对应的value for i := 0; i \u0026lt; inputType.NumField(); i++ { field := inputType.Field(i) value := inputValue.Field(i).Interface() fmt.Printf(\u0026#34;%s: %v = %v\\n\u0026#34;, field.Name, field.Type, value) } //通过type 获取里面的方法,调用 for i := 0; i \u0026lt; inputType.NumMethod(); i++ { m := inputType.Method(i) fmt.Printf(\u0026#34;%s: %v\\n\u0026#34;, m.Name, m.Type) } } 结构体标签 给结构体变量绑定多个标签，目前见过的例子有json的序列化字段名\n通过反射获取结构体标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) type resume struct { Name string `info:\u0026#34;name\u0026#34; doc:\u0026#34;我的名字\u0026#34;` Sex string `info:\u0026#34;sex\u0026#34;` } func findTag(str interface{}) { t := reflect.TypeOf(str).Elem() for i := 0; i \u0026lt; t.NumField(); i++ { taginfo := t.Field(i).Tag.Get(\u0026#34;info\u0026#34;) tagdoc := t.Field(i).Tag.Get(\u0026#34;doc\u0026#34;) fmt.Println(\u0026#34;info: \u0026#34;, taginfo, \u0026#34; doc: \u0026#34;, tagdoc) } } func main() { var re resume findTag(\u0026amp;re) } json中的结构体标签：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 package main import ( \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; ) type Movie struct { Title string `json:\u0026#34;title\u0026#34;` Year int `json:\u0026#34;year\u0026#34;` Price int `json:\u0026#34;rmb\u0026#34;` Actors []string `json:\u0026#34;actors\u0026#34;` } func main() { movie := Movie{\u0026#34;喜剧之王\u0026#34;, 2000, 10, []string{\u0026#34;xingye\u0026#34;, \u0026#34;zhangbozhi\u0026#34;}} //编码的过程 结构体---\u0026gt; json jsonStr, err := json.Marshal(movie) if err != nil { fmt.Println(\u0026#34;json marshal error\u0026#34;, err) return } fmt.Printf(\u0026#34;jsonStr = %s\\n\u0026#34;, jsonStr) //解码的过程 jsonstr ---\u0026gt; 结构体 //jsonStr = {\u0026#34;title\u0026#34;:\u0026#34;喜剧之王\u0026#34;,\u0026#34;year\u0026#34;:2000,\u0026#34;rmb\u0026#34;:10,\u0026#34;actors\u0026#34;:[\u0026#34;xingye\u0026#34;,\u0026#34;zhangbozhi\u0026#34;]} myMovie := Movie{} err = json.Unmarshal(jsonStr, \u0026amp;myMovie) // 结构体传参是值传递，因此需要传指针 if err != nil { fmt.Println(\u0026#34;json unmarshal error \u0026#34;, err) return } fmt.Printf(\u0026#34;%v\\n\u0026#34;, myMovie) } goroutine 协程是比线程更轻量级的运行单元\nGMP模型相关：\nhttps://go.cyub.vip/gmp/gmp-model/\nhttps://learnku.com/articles/41728\ngoroutine创建执行：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) // 子goroutine func newTask() { i := 0 for { i++ fmt.Printf(\u0026#34;new Goroutine : i = %d\\n\u0026#34;, i) time.Sleep(1 * time.Second) } } // 主goroutine // 主goroutine如果退出，则子goroutine也会立即退出 func main() { //创建一个go程 去执行newTask() 流程 go newTask() //fmt.Println(\u0026#34;main goroutine exit\u0026#34;) i := 0 for { i++ fmt.Printf(\u0026#34;main goroutine: i = %d\\n\u0026#34;, i) time.Sleep(1 * time.Second) } } 匿名函数方法创建和执行协程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; \u0026#34;time\u0026#34; ) func main() { // 用go创建承载一个形参为空，返回值为空的一个函数 go func() { defer fmt.Println(\u0026#34;A.defer\u0026#34;) func() { defer fmt.Println(\u0026#34;B.defer\u0026#34;) // 退出当前goroutine，但还是会调用defer runtime.Goexit() fmt.Println(\u0026#34;B\u0026#34;) }() // 小括号，表示调用，如果不加小括号只是声明了这个函数 fmt.Println(\u0026#34;A\u0026#34;) }() go func(a int, b int) bool { fmt.Println(\u0026#34;a = \u0026#34;, a, \u0026#34;, b = \u0026#34;, b) return true }(10, 20) //死循环 for { time.Sleep(1 * time.Second) } } channel 两个协程之间的通信机制\n1.无缓冲的channel：谁先到谁阻塞，直到完成对接，双方释放。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 package main import \u0026#34;fmt\u0026#34; func main() { //定义一个channel c := make(chan int) go func() { defer fmt.Println(\u0026#34;goroutine结束\u0026#34;) fmt.Println(\u0026#34;goroutine 正在运行...\u0026#34;) c \u0026lt;- 666 //将666 发送给c fmt.Println(\u0026#34;goEnd\u0026#34;) }() num := 1 //num := \u0026lt;-c //从c中接受数据，并赋值给num // 由于main和go协程并发执行，在管道读写代码处，会互相等待握手，确保同步获取到，再执行后续代码 fmt.Println(\u0026#34;num = \u0026#34;, num) fmt.Println(\u0026#34;main goroutine 结束...\u0026#34;) } 2.有缓冲的channel：当channel有元素时随放随拿，当channel满时，再往里写数据会阻塞；当channel为空，从里面取数据也会阻塞。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;time\u0026#34; ) func main() { c := make(chan int, 3) //带有缓冲的channel fmt.Println(\u0026#34;len(c) = \u0026#34;, len(c), \u0026#34;, cap(c)\u0026#34;, cap(c)) // 这里拿不到元素会阻塞，main协程状态转到asleep //for i := 0; i \u0026lt; 4; i++ { //\tnum := \u0026lt;-c // 从c中接收数据，并赋值给num //\tfmt.Println(\u0026#34;num = \u0026#34;, num) //} go func() { defer fmt.Println(\u0026#34;子go程结束\u0026#34;) for i := 0; i \u0026lt; 4; i++ { c \u0026lt;- i fmt.Println(\u0026#34;子go程正在运行, 发送的元素=\u0026#34;, i, \u0026#34; len(c)=\u0026#34;, len(c), \u0026#34;, cap(c)=\u0026#34;, cap(c)) } }() time.Sleep(2 * time.Second) for i := 0; i \u0026lt; 4; i++ { num := \u0026lt;-c //从c中接收数据，并赋值给num fmt.Println(\u0026#34;num = \u0026#34;, num) } fmt.Println(\u0026#34;main 结束\u0026#34;) } channel开关控制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 package main import \u0026#34;fmt\u0026#34; func main() { c := make(chan int) go func() { defer func() { fmt.Println(\u0026#34;go end\u0026#34;) }() for i := 0; i \u0026lt; 5; i++ { c \u0026lt;- i //close可以关闭一个channel //close(c) } close(c) // 关闭一个channe }() for { // ok如果为true表示channel没有关闭，如果为false表示channel已经关闭 if data, ok := \u0026lt;-c; ok { fmt.Println(data) } else { break } } // 上面这个for等价于： //可以使用range来迭代不断操作channel for data := range c { fmt.Println(data) } // 可见，消费者当channel closed且没有元素时，ok=false/跳出range循环，否则会阻塞 fmt.Println(\u0026#34;Main Finished..\u0026#34;) } 往关闭之后的channel发数据，会报panic；但关闭后还能从channel接收数据\nchannel的select操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 package main import \u0026#34;fmt\u0026#34; func fibonacii(c, quit chan int) { x, y := 1, 1 for { select { case c \u0026lt;- x: //如果c可写，则该case就会进来 x = y y = x + y case \u0026lt;-quit: fmt.Println(\u0026#34;quit\u0026#34;) return } } } func main() { c := make(chan int) quit := make(chan int) //sub go go func() { defer func() { fmt.Println(\u0026#34;go end\u0026#34;) }() for i := 0; i \u0026lt; 10; i++ { fmt.Println(\u0026lt;-c) } quit \u0026lt;- 0 }() //main go fibonacii(c, quit) } select关键字是专门针对管道操作，和switch无关。\n能够让当前goroutine同时等待多个channel可读或可写，当任意一个ready时立刻执行该case，若同时多个case都ready，会随机选择一个执行。\n","date":"2025-07-19T18:12:46+08:00","image":"https://jimmie-wang.github.io/p/java2goland/JavaVSGO_hu_6a42d58929a9f59b.png","permalink":"https://jimmie-wang.github.io/p/java2goland/","title":"Java2goland"}]